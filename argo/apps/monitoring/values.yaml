domain: REPLACE_ME
cluster_name: REPLACE_ME

####################################################################################################
# Alloy
####################################################################################################

alloy:
  enabled: true
  controller:
    type: statefulset # Needed for clustering
    replicas: 1
  ingress:
    enabled: true
    annotations:
      cert-manager.io/cluster-issuer: letsencrypt
    ingressClassName: internal-shared
    faroPort: 12345 # Fake faro so we have access to the UI
    extraPaths:
      - path: /faro
        pathType: Prefix
        backend:
          service:
            name: monitoring-alloy
            port:
              number: 12347
  alloy:
    clustering:
      enabled: false
    stabilityLevel: experimental
    configMap:
      content: |
        logging {
          level = "info"
          format = "json"
        }

        livedebugging {
          enabled = true
        }

        // Shared config
        discovery.kubernetes "node" {
          role = "node"
        }

        // Temporarily commenting out remote config to troubleshoot
        // remotecfg {
        //   url = env("REMOTE_CONFIG_URL")
        //   bearer_token = env("TOKEN")
        // }

        ////////////////////////////////////////////////////////////////////////
        // Metrics
        ////////////////////////////////////////////////////////////////////////

        // Relabel block to drop specific metrics before shipping to mimir
        prometheus.relabel "filter_metrics" {
          forward_to = [prometheus.remote_write.mimir.receiver]

          rule {
            source_labels = ["__name__"]
            regex = "etcd_request_duration_seconds_bucket|apiserver_request_sli_duration_seconds_bucket"
            action = "drop"
          }
        }

        // We use the servicemonitor to allow services their own control
        // over how they are scraped
        prometheus.operator.servicemonitors "services" {
          clustering {
            enabled = false
          }
          forward_to = [prometheus.relabel.filter_metrics.receiver]
        }

        prometheus.operator.podmonitors "pods" {
          forward_to = [prometheus.relabel.filter_metrics.receiver]
        }

        prometheus.exporter.cadvisor "cadvisor" {}

        prometheus.scrape "cadvisor" {
          targets = prometheus.exporter.cadvisor.cadvisor.targets
          forward_to = [prometheus.relabel.filter_metrics.receiver]
        }

        discovery.relabel "node_cadvisor" {
          targets = discovery.kubernetes.node.targets

          rule {
            regex  = "__meta_kubernetes_node_label_(.+)"
            action = "labelmap"
          }

          rule {
            target_label = "__address__"
            replacement  = "kubernetes.default.svc:443"
          }

          rule {
            source_labels = ["__meta_kubernetes_node_name"]
            regex         = "(.+)"
            target_label  = "__metrics_path__"
            replacement   = "/api/v1/nodes/$1/proxy/metrics/cadvisor"
          }
        }

        prometheus.scrape "node_cadvisor" {
          targets = discovery.relabel.node_cadvisor.output
          forward_to = [prometheus.relabel.filter_metrics.receiver]

          scheme = "https"
          tls_config {
            server_name = "localhost"
            ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
            insecure_skip_verify = false
          }
          bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        }

        prometheus.scrape "node" {
          targets = discovery.kubernetes.node.targets
          forward_to = [prometheus.relabel.filter_metrics.receiver]

          scheme = "https"
          tls_config {
            server_name = "localhost"
            ca_file = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
            insecure_skip_verify = false
          }
          bearer_token_file = "/var/run/secrets/kubernetes.io/serviceaccount/token"
        }

        prometheus.remote_write "mimir" {
          endpoint {
            url = env("PROMETHEUS_URL") + "/api/prom/push"
            basic_auth {
              username = env("GRAFANA_USER")
              password = env("TOKEN")
            }
          }
        }

        ////////////////////////////////////////////////////////////////////////
        // Logs
        ////////////////////////////////////////////////////////////////////////

        discovery.kubernetes "pod" {
          role = "pod"
        }

        discovery.relabel "pod_logs" {
          targets = discovery.kubernetes.pod.targets

          rule {
            source_labels = ["__meta_kubernetes_namespace"]
            action        = "replace"
            target_label  = "namespace"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_name"]
            action        = "replace"
            target_label  = "pod"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_container_name"]
            action        = "replace"
            target_label  = "container"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_label_app_kubernetes_io_name"]
            action        = "replace"
            target_label  = "app"
          }

          rule {
            source_labels = ["__meta_kubernetes_namespace", "__meta_kubernetes_pod_container_name"]
            action        = "replace"
            target_label  = "job"
            separator     = "/"
            replacement   = "$1"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_uid", "__meta_kubernetes_pod_container_name"]
            action        = "replace"
            target_label  = "__path__"
            separator     = "/"
            replacement   = "/var/log/pods/*$1/*.log"
          }

          rule {
            source_labels = ["__meta_kubernetes_pod_container_id"]
            action        = "replace"
            target_label  = "container_runtime"
            regex         = "^(\\S+):\\/\\/.+$"
            replacement   = "$1"
          }
        }

        loki.source.kubernetes "in_cluster" {
          targets = discovery.relabel.pod_logs.output
          forward_to = [loki.process.pod_logs.receiver]
        }

        loki.process "pod_logs" {
          stage.cri {}

          forward_to = [loki.write.loki.receiver]
        }

        loki.write "loki" {
          endpoint {
            url = env("LOKI_URL") + "/loki/api/v1/push"
            basic_auth {
              username = env("LOKI_USER")
              password = env("TOKEN")
            }
          }
        }

####################################################################################################
# Node Exporter
####################################################################################################

prometheus-node-exporter:
  enabled: true
  prometheus:
    monitor:
      enabled: true
